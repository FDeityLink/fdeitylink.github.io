<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootswatch@5.1.3/dist/darkly/bootstrap.min.css" integrity="sha256-VZi/r/RC1MritcGE2Yyxb/ACi8WIOj1Y7BHuslF8+6I=" rel="stylesheet"><link href="/css/styles.css" rel="stylesheet" type="text/css"><title>Introducing Lisp | FDeityLink</title></head><body><nav class="navbar sticky-top navbar-expand-lg navbar-dark bg-primary"><div class="container-fluid"><a class="navbar-brand" href="/">FDeityLink</a><button aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle Navigation" class="navbar-toggler" data-bs-target="#navbarColor01" data-bs-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarColor01"><ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="/blog/">Blog</a></li><li class="nav-item"><a class="nav-link" href="/projects/">Projects</a></li><li class="nav-item"><a class="nav-link" href="/about.html">About</a></li></ul></div></div></nav><br><div class="card"><h2 class="card-header">Introducing Lisp</h2><div class="card-body"><h6 class="card-subtitle mb-2 text-muted">2019-12-01</h6><p class="card-text lead">This post is a basic introduction and broad overview of the Lisp programming language. It prefaces a series that will educate you, the reader, as to what Lisp is, what it does, why it's great, and so on.<br></p><hr><p class="card-text"><h3>Rationale</h3><p>You might be wondering why I have chosen to discuss Lisp. If you've never heard of it, then you have no idea what it is and what I'm about to spend a few precious weeks writing about. If you <i>have</i> heard of it, chances are what you have heard may have been inaccurate or off-putting. I'll admit it &ndash; Lisp can seem a bit weird at first, even to the point where you'd write it off as pointless, unnecessary, or impractical.</p><p>Everything above is <i>precisely</i> the reason I'm writing about Lisp. If you're new to it, I want to educate you about it. If you've heard of it, I want to <b>re</b>educate you, to provide you with a more informed and holistic view. In either case, after reading this series, you should have at least some basic understanding of the what, why, and how of Lisp.</p><p>Another question, which perhaps you're not even asking but which I will answer anyway: Why have I chosen to start off what will (hopefully) be a long-running blog with Lisp posts?</p><p>It's simple, really. I'm passionate about it.</p><p>If you look at <a href='https://github.com/fdeitylink?tab=repositories'>my recent GitHub projects</a>, you'll see that quite a few of my projects are written in Clojure, an offshoot of Lisp. Surely I must like the language enough to use it time and time again. True, it is possible that some other flashy language will enrapture me soon, but for the time being, Lisp is very exciting to me and many others. And why is that? Well I'll explain most of that later, but the summary is that Lisp allows me to think about and write my code in a way that I find to be clean, elegant, and overall more productive. There are finicky bugs and issues I have run into with other programming languages that I simply don't with Lisp. I spend more time on problem-solving instead of bugfixing. This is nodded to in the following xkcd comics.</p><p><a href='https://xkcd.com/224/'><img src="https://imgs.xkcd.com/comics/lisp.jpg" alt="" title= "xkcd 224: Lisp" /></a><br /> We lost the documentation on quantum mechanics.  You'll have to decode the regexes yourself.</p><p><a href='https://xkcd.com/297/'><img src="https://imgs.xkcd.com/comics/lisp_cycles.png" alt="" title= "xkcd 297: Lisp Cycles" /></a><br /> I've just received word that the Emperor has dissolved the MIT computer science program permanently.</p><p>Furthermore, I wish to share this passion with you. It is my hope that, by the end of this series of posts, you will, if not <i>use</i> Lisp, understand its merits and apply some of its principles as you program.</p><p>Onto Lisp!</p><h3>Definition</h3><p>Any good explanation should begin with some kind of basic definition to serve as context for what is to come. Lisp is a bit of a nuanced language, distanced from more mainstream ones (i.e. the C family, including C, C++, Java, etc.), which necessitates a definition that explains these nuances and their origins.</p><h4>A Language Family</h4><p>First things first. Lisp is <i>not</i> a programming language!</p><p>"<i>What? How? If it's not a programming language, what is it? And why are you bothering to write about it?</i>" you exclaim with a fervor.</p><p>Settle down, I'm not throwing you under the bus.</p><p>Lisp is not a programming language; it's something better. It's a family of closely related programming languages dating back to 1958.</p><p>Each language serves a unique purpose and bears some distinct and innovative features. These may be built into the language, its execution model, its standard library, or some combination of the three. Here are some examples</p><ul><li><a href='https://clojure.org/'>Clojure</a> - a Lisp dialect for the Java ecosystem with a strong focus on immutability and concurrency</li><li><a href='https://gnu.org/software/emacs/manual/html_node/elisp/'>Emacs Lisp</a> - a Lisp dialect for programming and extending the <a href='https://gnu.org/software/emacs/'>Emacs text editor</a></li><li><a href='http://docs.hylang.org/en/stable/'>Hy</a> - a Lisp dialect for the Python ecosystem</li><li><a href='https://ferret-lang.org/'>Ferret</a> - a Lisp for embedded systems development</li></ul><p>However, most if not all Lisps share some defining features, such as those below</p><ul><li>Programs are written as "S-expressions" (short for "symbolic expressions") represented as lists of the form <code>&#40;function arg-1 arg-2 arg-3&#41;</code></li><li>Lisp languages follow and arguably developed the functional programming paradigm</li><li>Metaprogramming with powerful macro systems - Since Lisp code is written with lists and functions can manipulate lists, Lisp code can manipulate itself</li></ul><p>Lisps have come and gone over the years (61 years as of writing, to be exact, demonstrating its continual success). Sure, it might be depressing for a language to fall out of use, but the close relationship of Lisp languages in a family provides an important benefit: learning one Lisp simplifies learning the rest.</p><p>This has some important advantages.</p><p>For one, if one language falls out of favor, it is not too hard to pick up a new one and start using it. Lisps have many characteristics in common, enabling developers to reference the same repertoire when using different dialects.</p><p>Another benefit of Lisp is that different Lisp dialects can specialize for different application domains while retaining the core principles that make Lisp what it is. With mainstream languages, each domain generally requires a new language with its own syntax, semantics, and paradigm, all of which take up precious time and head space to develop skills in. But with Lisp, many core features will remain the same, so there is less cognitive overload in developing for a new domain. Consider the move from web development to low level development &ndash; JavaScript and C are <i>very</i> different languages, whereas two Lisps, one for each domain, will have much more in common.</p><p>For instance, many Lisp developers use Emacs as their text editor. Emacs can be manipulated with Emacs Lisp, which is very easy to pick up once you already know one Lisp.</p><p>Now let's get into what Lisp really <i>is</i>.</p><h4>LISt Processor</h4><p>I mentioned this earlier, but Lisp code is written with lists. Lots of lists. Hence its name actually stands for <strong>LIS</strong>t <strong>P</strong>rocessor, since Lisp runtimes execute code by processing a series of lists. As such, not only are lists important as core data structures, but they are core to the very nature of Lisp itself. Take a look at the following (interactive!) code sample, written in Clojure.</p><pre><code class="klipse-clojure">&#40;println &quot;hello, world!&quot; &quot;goodbye, world!&quot;&#41;
</code></pre><p>Lists are denoted by opening and closing parentheses. When evaluated, the first element is treated as a function, while subsequent elements are treated as arguments. In the above code, we pass the <code>println</code> (print line) function two strings (<code>&quot;hello, world!&quot;</code> and <code>&quot;goodbye, world!&quot;</code>). <i>Voila!</i> The two strings are printed, one after another.</p><p>After the printout, <code>nil</code> appears. This is the empty value (equivalent to <code>null</code> in other languages). Here, it's just <code>println</code>'s return value.</p><p>So lists are function calls. Neat! But you can also treat lists as normal data structures, like in most languages.</p><pre><code class="klipse-clojure">&#40;first '&#40;1 2 3&#41;&#41;
</code></pre><p>Here, we grab the first element of the list <code>&#40;1 2 3&#41;</code>. The <code>'</code> prefix essentially forces the list to be treated as a data structure rather than being evaluated as a function call. Then <code>first</code> grabs the first element of the given list, which in this case is <code>1</code>.</p><p>Pretty simple stuff, right?</p><p>Well remember how I mentioned macro systems earlier? The fact that lists are, by default, treated as function calls and that functions can manipulate these very same lists allows programmers to define macros that manipulate source code. The following is a very simple and impractical example, but it gets the point across.</p><pre><code class="klipse-clojure">&#40;println &quot;Hello&quot; &quot;World&quot;&#41;
&#40;eval &#40;butlast '&#40;println &quot;Hello&quot; &quot;World&quot;&#41;&#41;&#41;
</code></pre><p>Above, we begin with simply printing out <code>&quot;Hello World&quot;</code>. Not too hard to grasp.</p><p>The next line is what's interesting. Beginning with the innermost term, we have the list <code>&#40;println &quot;Hello&quot; &quot;World&quot;&#41;</code>. Notice it is prefixed with a <code>'</code>, so it will <i>not</i> be evaluated as a function call, at least not yet! Then we use the <code>butlast</code> function to construct a new list that contains every element except the last one. Finally, we use <code>eval</code>, which evaluates a data structure. In this case, the data structure is the list <code>&#40;println &quot;Hello&quot;&#41;</code>. When evaluated, <code>println</code> is treated as a function and <code>&quot;Hello&quot;</code> as an argument. So we print out <code>Hello</code>. <code>&quot;World&quot;</code> was dropped out of the code by <code>butlast</code> so it was not printed.</p><p>Again, this is a very rudimentary and unrealistic example, but it shows how code can be manipulated as data <i>before</i> finally being evaluated. This property of Lisp is known as <i>homoiconicity</i> &ndash; code and data have the same representation so each can be treated as the other. Code is data and data is code, which lends to an incredibly powerful macro system.</p><h3>Lisp in the Real World</h3><p>Alright, enough of that. You'll get some more practice with how to use Lisp in future posts. For now, let's focus on Lisp's origins and it's importance to computer science, both theoretical and practical.</p><h4>Origins</h4><p>Lisp originated at M.I.T. in John McCarthy's influential paper <a href='http://www-formal.stanford.edu/jmc/recursive.pdf'>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</a>. The name is quite a mouthful, but the paper essentially defined Lisp, the rationale behind it, and some of its implications.</p><p>Lisp was created by M.I.T.'s Artificial Intelligence team to implement a proposed system called <i>Advice Taker</i>, which would receive information and instructions and demonstrate some level of common sense and logical reasoning. To achieve these goals, Lisp would need to be able to manipulate expressions representing inputs to <i>Advice Taker</i>. This was achieved in part via Lisp's support for self-modifying code. Much artificial intelligence research over the coming decades was fueled by Lisp, with many natural language processing programs written in it.</p><p>Lisp was also introduced as a more practical notation for lambda calculus, a Turing-complete model of computation. Lambda calculus was introduced in the 1930s by Alonzo Church and approaches computation in a manner that is built around functions and binding names to values. Functional programming languages take many concepts both from Lisp and lambda calculus.</p><h4>Impact and Implications</h4><p>Lisp is a fully Turing-complete language built with a remarkably small syntax and set of operations (as you will see later, even things like function definitions aren't very fancy &ndash; they're written as lists!). This lends to many programmers calling it an <i>elegant</i> language. It does not take up much head space and it's very easy to read, since only a few core concepts and language features have to be learned in order to understand any Lisp code. This also makes it trivial for you to <a href='https://github.com/kanaka/mal'>make your <i>own</i> Lisp</a>! Granted, many Lisp languages have added additional features on top of the original proposal, but they are very careful to avoid introducing too many new concepts and many of these additions were arguably necessary for practical use. For instance, the original Lisp proposal lacked explicit support for even basic integers (there were ways to hack it in there, but adding them outright was certainly far easier). Do not misinterpret this to mean that Lisp is simple in what it can <i>do</i>, hoewver &ndash; its syntax may be simple but it is an immensely powerful language.</p><h5>The REPL</h5><p>Lisp's runtime strategy is also very important. Because of Lisp's <code>eval</code> function, shown above, it is trivial to implement a Read &ndash; Eval &ndash; Print Loop (a <i>REPL</i>), where users can type in code and have it evaluated instantly. The REPL program flow looks like the following</p><p>Read &ndash; Eval &ndash; Print Loop Program Flow</p><ol><li>The user is prompted to enter some Lisp code</li><li>Lisp code is passed to the program as text</li><li>The Lisp reader parses the text into Lisp data structures</li><li>The data structures are passed to the evaluator, which evaluates the structures</li><li>The final evaluated value is displayed to the user</li><li>The program loops, beginning again at step 1</li></ol><p>Lisp's REPL and macro system demonstrate that Lisp makes no difference between compile-time and runtime. New code can be compiled and evaluated during runtime, and, during compile time, code can be run to produce new code to compile and evaluate. The REPL system also makes it extremely easy to prototype code. There is no lengthy compilation phase or setup required to try new code &ndash; just type it in and see if it works. If it doesn't, try again until you are satisfied. Many popular programming languages today feature REPL systems (see <a href='https://repl.it'>repl.it</a>, for instance) that you can thank Lisp and John McCarthy for. The ability to read and analyze new code during runtime also relates back to Lisp's roots with <i>Advice Taker</i>, since it would need to analyze user input, produce code, and evaluate it.</p><h5>Functional Programming</h5><p>Finally, Lisp introduced the functional programming paradigm, which is still going strong today and becoming increasingly popular among developers. Functional programming is born out of mathematics and bears a number of resemblences. For instance, variables aren't usually <i>variable</i> in math; that is, they are <i>immutable</i>. Functional programming encourages the use of immutable values rather than mutable variables and mutating state. Pure functions are also heavily encouraged. These functions derive their return values solely from their arguments (i.e. no global state affects them) and do not result in any side-effects (i.e. their only purpose is producing a return value). Such functions are easier to test and use in a variety of situations, since they are truly isolated from their environments and don't require anything to be set up besides their input arguments. There are some other neat features, such as <a href='https://en.wikipedia.org/wiki/Referential_transparency'>referential transparency</a> or <a href='https://en.wikipedia.org/wiki/Memoization'>memoization</a>, but I won't go into detail about them here.</p><p>One other core feature of functional programming languages is <i>higher-order functions</i>, which are functions that receive functions as arguments and/or return them as values. In Lisp, this is enabled in part by homoiconicity. Since functions are code and code is data and functions can receive and return data, they can receive and return functions. Again, Lisp is a very simple language but it really has a lot of features that make it incredibly powerful.</p><p>One very important higher-order-function is called <code>apply</code>, which takes a function and a list of arguments and <i>applies</i> (invokes, essentially) the function to the arguments. See the following example with addition below.</p><pre><code class="klipse-clojure">&#40;println &#40;apply + '&#40;1 2 3&#41;&#41;&#41;
;; This is equivalent to
&#40;println &#40;+ 1 2 3&#41;&#41;
</code></pre><p>Above, the addition function (<code>+</code>) is <i>applied</i> to the arguments <code>1</code>, <code>2</code>, and <code>3</code>, producing <code>6</code>, the sum of the three numbers. <code>apply</code> is a higher-order function because it takes a function as its first argument. <code>apply</code> is very important for the Lisp execution model. When a list such as <code>&#40;+ 1 2 3&#41;</code> is evaluated, the evaluator actually invokes <code>apply</code> -- <code>+</code> is the function and <code>&#40;1 2 3&#41;</code> is the list of arguments.</p><p>You'll see in future posts how important higher-order functions are for writing code that is clearer and more <i>elegant</i>. (there's that word again!)</p><h3>Conclusion</h3><p>There are many, many, <i>many</i> more impacts that Lisp has had across the computer science spectrum, too many to put into one blog post, but the ones I've listed are arguably some of the most important. Hopefully I have sparked enough interest in you that you will seek these things out on your own, because Lisp truly is a magnificent thing.</p><p>In the next post, we will explore how to write Lisp code and how to <i>think</i> about writing Lisp code, because chances are it's different from how you've written code in the past. Stay tuned!</p><h3>Further Reading</h3><p>If you're interested in learning more about Lisp, I suggest looking at the following resources</p><ul><li><a href='https://braveclojure.com/clojure-for-the-brave-and-true/'>Clojure for the Brave and True</a> - a free ebook that teaches readers how to use Clojure</li><li><a href='http://paulgraham.com/lisp.html'>Paul Graham's writings on Lisp</a></li></ul></p></div></div><link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script><script>hljs.highlightAll();</script><link href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" rel="stylesheet" type="text/css"><script>window.klipse_settings = {selector: '.klipse-clojure'};</script><script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script><script crossorigin="anonymous" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script></body></html>