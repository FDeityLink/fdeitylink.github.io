<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootswatch@5.1.3/dist/darkly/bootstrap.min.css" integrity="sha256-VZi/r/RC1MritcGE2Yyxb/ACi8WIOj1Y7BHuslF8+6I=" rel="stylesheet"><link href="/css/styles.css" rel="stylesheet" type="text/css"><title>Writing Lisp | FDeityLink</title></head><body><nav class="navbar sticky-top navbar-expand-lg navbar-dark bg-primary"><div class="container-fluid"><a class="navbar-brand" href="/">FDeityLink</a><button aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle Navigation" class="navbar-toggler" data-bs-target="#navbarColor01" data-bs-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarColor01"><ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="/blog/">Blog</a></li><li class="nav-item"><a class="nav-link" href="/projects/">Projects</a></li><li class="nav-item"><a class="nav-link" href="/about.html">About</a></li></ul></div></div></nav><br><div class="card"><h2 class="card-header">Writing Lisp</h2><div class="card-body"><h6 class="card-subtitle mb-2 text-muted">2019-12-02</h6><p class="card-text lead">This post is an introduction to programming in Clojure, a Lisp dialect, including how to code and how to think about coding.<br></p><hr><p class="card-text"><h3>Recap</h3><p>Earlier, we explored what Lisp is, some of its core elements, its origins, and its impacts on the computer science community. You also got a little sneak peek of what Lisp code looks like and how to write some. Hopefully you took advantage of the interactive code samples and played around with them to see what would happen. Now we will delve further into writing Lisp code and how that may differ from languages you've experienced in the past (not only in the syntax of course, but also in the paradigm and common idioms).</p><p>So let's begin!</p><p><strong>Note</strong>: This tutorial focuses on Clojure, which has some particular nuances separate from other Lisps, but many of the principles remain the same.</p><h3>Hello World</h3><p>Any language tutorial worth its salt begins with a Hello World example, a tradition dating back to <i>The C Programming Language</i>. So we're going to begin with just that.</p><pre><code class="klipse-clojure">&#40;println &quot;Hello, world!&quot;&#41;
</code></pre><p>You saw something very similar in the last post, but here we'll dissect it more thoroughly, piece by piece.</p><p>We begin with <code>&#40;</code>, the opening parenthesis. This denotes the start of a list literal. The end is denoted by a matching <code>&#41;</code> All of the terms between the parenthesis &ndash; including any nested lists, which we don't have here but will later &ndash; are elements in the list we've denoted.</p><p>Inspecting the list, we see that it begins with the name (or <i>symbol</i> in Clojure) <code>println</code>. These names are similar to variable names in other languages, but we shy away from making anything actually <i>variable</i> in Lisp; in other words, most things are immutable and don't change their value. The next, and last, element in the list is just the string <code>&quot;Hello, world!&quot;</code>. That's our entire list.</p><p>It's pretty boring on its own. The magic happens when we <i>evaluate</i> it.</p><p>Lisp works by evaluating <i>forms</i>, which are essentially just values. Some refer to forms as "valid code". Forms include strings, integers, lists, and so on. When evaluating lists, a recursive strategy is used &ndash; evaluate each of its elements, then evaluate it as a whole.</p><p>The first element to evaluate is the symbol <code>println</code>. Symbols are evaluated by resolving them, or finding the value to which they are associated (just as variables are associated with values). When the Clojure runtime performs a lookup on <code>println</code>, it discovers a function in the Clojure standard library. Excellent!</p><p>The second element is very easy to evaluate. Many things simply evaluate to themselves, completely unchanged. Strings are one of them, so we simply get back <code>&quot;Hello, world!&quot;</code> post-evaluation.</p><p>Great! We have a function and we have a string. Now what?</p><p>We evaluate the list as a whole of course! This is done by taking the first element (well, the result of evaluating it anyway) and applying it as a function to the remaining elements (again, their evaluated forms). We apply the function we retrieved earlier from <code>println</code> to <code>&quot;Hello, world!&quot;</code>. A whole bunch of magic (that I could write pages upon pages upon pages about) happens inside the <code>println</code> function that displays the input text and then returns <code>nil</code>.</p><p>Whod've thought that something as elementary as Hello World could be so complicated? There are a lot of moving parts to it, so reread the section if you have to of course. The evaluation strategy described above proves indispensible to the majority of Lisp's functionality.</p><h3>Definitions</h3><p>Running computations is great, but what good are they if you can't store them? Well we'll get into that now!</p><p>To associate a name (a symbol) to some value, you would write code such as the following</p><pre><code class="klipse-clojure">&#40;def foo 1&#41;
&#40;def bar &#40;+ 1 2 3&#41;&#41;
&#40;println foo bar&#41;
</code></pre><p><code>def</code> simply defines a new symbol-to-value association. The value can then be referenced later by using the bound name.</p><p>If you want to define a <i>function</i>, you use <code>defn</code> ("define function"). For example</p><pre><code class="klipse-clojure">&#40;defn times-2
  &#91;n&#93;
  &#40;&#42; n 2&#41;&#41;
&#40;times-2 5&#41;
</code></pre><p><code>defn</code> takes a symbol for naming the new function, a <i>vector</i> of symbols for the function's parameters, and finally the function body. If the body is composed of multiple forms, the result of evaluating the last one is the function's return value. Vectors are similar to lists, but have some core differences. For one, when they are evaluated, they evaluate to themselves. They are not used to represent function invocations. Additionally, at a lower level, vectors are more like arrays and provide performant random element access while lists are linked lists and do not provide this performance. Here, the <code>times-2</code> definition uses a vector containing just the symbol <code>a</code> which, during invocations of <code>times-2</code>, will be bound to whatever argument value was passed in (such as <code>5</code> above).</p><pre><code class="klipse-clojure">&#40;defn constant
  &#91;&#93;
  &#40;println &quot;hi!&quot;&#41;
  &quot;bye!&quot;&#41;
&#40;constant&#41;
</code></pre><p>Here's another example. In this case, the function takes no parameters (empty vector) and has two forms in the body. After invoking <code>println</code>, the function always yields the string <code>&quot;bye!&quot;</code>.</p><p>The third type of definition is more temporary, using <code>let</code> expressions. With these, we bind names to values, but only temporarily. Outside the scope of the expression, that binding is gone.</p><pre><code class="klipse-clojure">&#40;let &#91;string &quot;hello there!&quot;&#93;
  &#40;println &#40;count string&#41;&#41;&#41;
;;string
</code></pre><p>Above, we temporarily bind <code>string</code> to a string and print out its length. But once we're finished with the <code>let</code>, the binding is gone and an error occurrs when trying to access it. (In the context of the above interactive snippet, there is a warning and <code>string</code> evaluates to <code>nil</code> because of how the Clojure code is compiled and run in your browser, but the point is that the binding is truly gone). Also, just like with functions, the last form in a <code>let</code> is used for the final evaluated result.</p><p>One final thing. Notice that all of the code above <i>used lists!</i> Lists are fundamental to Lisp code &ndash; everything uses them!</p><h3>Control Flow</h3><p>Now that we've covered some basics, let's get into control flow, which occurs with simple if-else branching as well as looping.</p><h4><code>If</code> Expressions</h4><p>The first type of control flow we'll discuss is the <code>if</code> expression, which takes a <i>test</i> form, <i>then</i> form, and optional <i>else</i> form. The test form is evaluated. If it is determined to be <i>truthy</i> (more on this later), then the then form is evaluated. Otherwise, if an else form was provided, that gets evaluated. If there was no else form, the <code>if</code> expression evaluates to <code>nil</code>. Below are some examples.</p><pre><code class="klipse-clojure">;; Test case is true, so then form is evaluated
&#40;if true
  &#40;println &quot;First is true&quot;&#41;&#41;
;; Test case is true, so then form is evaluated
&#40;if true
  &#40;println &quot;Second is true&quot;&#41;
  &#40;println &quot;Second is false&quot;&#41;&#41;
;; Test case is false, so else form is evaluated
&#40;if false
  &#40;println &quot;Third is true&quot;&#41;
  &#40;println &quot;Third is false&quot;&#41;&#41;
;; Test case is false and no else form is provided, so the result is nil
&#40;if false
  &#40;println &quot;Fourth is true!&quot;&#41;&#41;
</code></pre><p>Notice that I've been talking about evaluation and saying <i>expression</i> rather than <i>statement</i>. That's because these <code>if</code> expressions actually evaluate to values -- whatever value was yielded by the selected branch. The term <i>statement</i> relates to imperative programming, which involves lots of state changing and mutability. We're trying our best to stick to functional programming, which means our code avoids state changes and side-effects, instead being used almost solely for the value it evaluates to. This goes along with sticking to pure functions, as I mentioned in the last post. <code>if</code> expressions <i>can</i> be used for side-effects (as done in the above examples with <code>println</code>) but they are expressions first and foremost. You can compare them to the ternary operator in some C-like languages (i.e. <code>test ? then : else</code>).</p><p>A form is truthy if it is not <code>false</code> and it is not <code>nil</code>. Everything else is truthy, no matter what.</p><h4>Looping</h4><p>The other main form of control flow is looping. Whether you're writing a loop in Lisp or some other language, it's the same basic concept, but you may be surprised by <i>how</i> you write the loops. Whereas you may be used to code like</p><pre><code class="java">List&lt;Integer&gt; ints = List.of&#40;0, 1, 2, 3, 4&#41;;
List&lt;Integer&gt; reversed = new ArrayList&lt;&gt;&#40;&#41;;
int i = ints.size&#40;&#41; - 1;

while &#40;i &gt;= 0&#41; {
    reversed.add&#40;ints.get&#40;i&#41;&#41;;
    i--;
}
</code></pre><p>This is a very imperative approach and uses that dreaded mutability that we're working very hard to avoid! Just look at the hideous <code>add</code> and the reassignment too! How can we avoid such unsightly code?</p><p>The answer is recursion!</p><pre><code class="klipse-clojure">&#40;let &#91;ints &#91;0 1 2 3 4&#93;&#93;
  &#40;loop &#91;i &#40;dec &#40;count ints&#41;&#41;
         reversed &#91;&#93;&#93;
    &#40;if &#40;&lt; i 0&#41;
      reversed
      &#40;recur &#40;dec i&#41; &#40;conj reversed &#40;get ints i&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>This is a bit of a complicated example but we'll go through it step by step of course. We start with a <code>let</code> that simply sets up <code>ints</code>, a vector of the numbers zero through four.</p><p>Inside of this is a <code>loop</code>, which sets up a recursive loop. <code>loop</code> first takes a vector containing symbols and initial values to bind them to. We bind <code>i</code> to the last index of <code>ints</code> and <code>reversed</code> to an empty vector.</p><p>Next is the body of the loop. We check if <code>i</code> is less than zero. If so, we're finished and can return <code>reversed</code>. Otherwise, we need to continue looping until we're complete. We use <code>recur</code> for this. <code>recur</code> returns to the nearest recursion point (such as <code>loop</code> or a function definition), rebinding the names to new values. The first new value is pretty simple - just one subtracted from <code>i</code>. The second value, which will later be rebound to <code>reversed</code>, is a new vector created by appending the value at index <code>i</code> in <code>ints</code> to the current value of <code>reversed</code>. <code>get</code> retrieves the value, <code>conj</code> creates a new vector by appending.</p><p>Once these values are computed, we recurse and the loop reruns the same code with the new bindings. When <code>i</code> is zero, <code>recur</code> is invoked one last time with <code>-1</code> and the complete reversed vector. In the next iteration of the loop, the recursive base case is satisfied and the reversed vector is returned.</p><p>Notice that nowhere did we actually mutate anything &ndash; no variables were reassigned and no vectors were changed. We derived new values and bound them to the symbol names in each recursive invocation.</p><p>We can also write the above code as a function, and change the style to be even more functional.</p><pre><code class="klipse-clojure">&#40;defn reversed
  &#91;xs rev&#93;
  &#40;if xs
    &#40;recur &#40;next xs&#41; &#40;cons &#40;first xs&#41; rev&#41;&#41;
    rev&#41;&#41;
&#40;reversed &#91;0 1 2 3 4&#93; &#91;&#93;&#41;
</code></pre><p>We create a function <code>reversed</code> that takes <code>xs</code> (a list, vector, etc. to reverse) and <code>rev</code> (the reversed version). If <code>xs</code> is truthy (i.e. not <code>nil</code> and not <code>false</code>), then we return the value of a recursive call. In the recursive invocation, <code>xs</code> is bound to a new sequence containing every value except the first, or <code>nil</code> if none are left (via <code>next</code>). For <code>rev</code>, we use <code>cons</code> to create a new sequence with ``xs``'s first value prepended to <code>rev</code>. Notice that the final result is a list, not a vector, even though we passed in a vector. <code>cons</code> always yields lists (many Clojure functions do, in fact, even when passed in a vector).</p><p>This code also follows a more functional approach by avoiding indices and just working on the heads (the fronts) of our sequences, adding and dropping elements with each recursive call. This makes it easier to reason about our code, especially because this approach focuses on what we want rather than more nitty gritty details like indices.</p><p>Recursion is often a more elegant way to express a number of functions or solutions to problems, so try to use it whenever possible.</p><h3>Higher-Order Functions</h3><p>The final topic of discussion is higher-order functions and all of Clojure's related facilities for dealing with them.</p><p>First, we must highlight that Lisps treat functions as values, just like numbers or lists. The easiest way to highlight this is with anonymous (unnamed) functions, which are essentially function literals. They take the form <code>&#40;fn &#91;args...&#93; body&#41;</code>. See the following example.</p><pre><code class="klipse-clojure">&#40;&#40;fn &#91;xs&#93; &#40;next &#40;butlast xs&#41;&#41;&#41; &#91;0 1 2 3 4&#93;&#41;
</code></pre><p>The outermost list contains two elements, an anonymous function and a vector. This anonymous function returns a list containing every element of its argument except the first and last. When the above list is evaluated, the anonymous function is applied to the vector, producing <code>&#40;1 2 3&#41;</code>. We could easily rewrite the above code as follows:</p><pre><code class="klipse-clojure">&#40;defn ends-dropped
 &#91;xs&#93;
 &#40;next &#40;butlast xs&#41;&#41;&#41;
&#40;ends-dropped &#91;0 1 2 3 4&#93;&#41;
</code></pre><p>They are roughly equivalent, except that the first never defines a named function, whereas the second does. Another way to show Lisp's support for functions as values is to evaluate a function.</p><pre><code class="klipse-clojure">&#40;fn &#91;&#93;&#41;
</code></pre><p>When we evaluate the anonymous function above (which receives nothing and yields <code>nil</code>), the environment tells us that it's value of the function type. Neat! Now that you understand how functions are values, we can delve into higher-order functions, which receive functions as arguments or return them. We covered <code>apply</code> in the last post; now let's discuss <code>map</code>.</p><p><code>map</code> takes a function and a sequence and returns a new sequence where each element has been replaced with the result of applying the function to the element. To convert a list of values to their string representations (with the <code>str</code> function), we use the following</p><pre><code class="klipse-clojure">&#40;map str &#91;0 &quot;hello&quot; &#91;1 2 3&#93;&#93;&#41;
</code></pre><p>For each element in the given vector, <code>str</code> was applied to it and a new list was constructed out of these string representations.</p><p>Some other useful higher-order functions include <code>comp</code> and <code>partial</code>.</p><p><code>comp</code> composes all functions passed to it, feeding the output of one to the input of the next. Take for example</p><pre><code class="klipse-clojure">&#40;def increment-str &#40;comp str inc&#41;&#41;
&#40;increment-str 5&#41;
</code></pre><p>By using <code>comp</code>, we create a function that increments a number and returns the string representation of the new number. When using <code>comp</code>, every function except the last supplied (which is the first to be invoked) must support taking a single argument, since they will just be passed the output of the previous function.</p><p><code>partial</code> will <i>partially apply</i> a function to some arguments, creating a new function in the process. When this new function is applied to some arguments, the net result is applying the original function to the partially applied arguments and the new arguments. If you wanted to add a prefix string to some other strings, you could do the following</p><pre><code class="klipse-clojure">&#40;map &#40;partial str &quot;prefix&#95;&quot;&#41; &#91;&quot;hello&quot; &quot;world&quot; &quot;yes&quot; &quot;no&quot;&#93;&#41;
</code></pre><p><code>str</code> is partially applied to the string <code>&quot;prefix&#95;&quot;</code> to create a new function that <code>map</code> uses. When we map over the elements of the vector, <code>str</code> is "completely" applied to <code>&quot;prefix&#95;&quot;</code> and the given element.</p><p>The overall benefit of higher order functions is that they provide another level of abstraction, which means you will write less code and the code that you <i>do</i> write will be clearer and more elegant. That <i>is</i> the essence of Lisp, after all!</p><p>Allow me to demonstrate this abstraction with <code>map</code>. In some other language, if you wanted to create a new list of values based on some initial list, you might write something like the following</p><pre><code class="java">List&lt;Integer&gt; ints = List.of&#40;0, 1, 2, 3, 4&#41;;
List&lt;Integer&gt; incrementedInts = new ArrayList&lt;&gt;&#40;&#41;;

for &#40;int n : ints&#41; {
    incrementedInts.add&#40;n + 1&#41;;
}
</code></pre><p>Now look at the same code in Clojure</p><pre><code class="klipse-clojure">&#40;map inc &#91;0 1 2 3 4&#93;&#41;
</code></pre><p>Much shorter! And much clearer too! You don't need the boilerplate of creating two variables and a for loop and invoking <code>add</code> and all that extra junk. Now you might argue that having two variables isn't bad, but there are many cases where the mapped sequence is just an intermediary value that you use to derive <i>another</i> value, and declaring an extra variable might not really be necessary or even helpful. <code>map</code>, like many other higher-order functions, abstracts over some process. Here, it's the process of building up a new sequence; you needn't concern yourself with iterating over the initial sequence, just with how to derive new values from old ones (the mapping function).</p><h3>Conclusion</h3><p>In this post, you have learned some of the basics of Clojure and what facilities it provides you with. Furthermore, you have begun to think in a functional style, which is probably unfamiliar to you if you're coming from a language like Java or C. Did you like it? Me too! Functional programming can really simplify a lot of code and make it clearer. Higher-order functions make this most explicit, as they reduce a lot of boilerplate, but recursive style is great for this too! In the next post, we will discuss Lisp's metaprogramming facilities &ndash; in other words, you will write code that writes code.</p><p><a href='https://youtu.be/ShEez0JkOFw'>Here</a> is an excellent talk drawing parallels between the simplicity of Clojure and of hand tools for woodworking. I highly recommend watching it!</p></p></div></div><link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script><script>hljs.highlightAll();</script><link href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" rel="stylesheet" type="text/css"><script>window.klipse_settings = {selector: '.klipse-clojure'};</script><script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script><script crossorigin="anonymous" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script></body></html>